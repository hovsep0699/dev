{"ast":null,"code":"/**\r\n * Breaks the value up into mask parts\r\n * @param mask Mask\r\n * @param value Input value\r\n */var parseValue=function parseValue(mask,value){var valueParts=[];var valueIndex=0;var maskIndex=0;while(value!==undefined&&valueIndex<value.length&&maskIndex<mask.length){var item=mask[maskIndex];var found=void 0;if(item.fixed){var length=item.fixed.length;valueParts.push({part:item.fixed,beginIndex:valueIndex,endIndex:valueIndex+length-1});var part=value.slice(valueIndex,valueIndex+length);if(part===item.fixed){valueIndex+=length;}maskIndex+=1;found=true;}if(!found){if(item.regexp){var minLength=Array.isArray(item.length)&&item.length[0]||item.length||1;var maxLength=Array.isArray(item.length)&&item.length[1]||item.length||value.length-valueIndex;var _length=maxLength;while(!found&&_length>=minLength){var _part=value.slice(valueIndex,valueIndex+_length);if(item.regexp.test(_part)){valueParts.push({part:_part,beginIndex:valueIndex,endIndex:valueIndex+_length-1});valueIndex+=_length;maskIndex+=1;found=true;}_length-=1;}if(!found){valueIndex=value.length;}}else{var _length2=Array.isArray(item.length)?item.length[1]:item.length||value.length-valueIndex;var _part2=value.slice(valueIndex,valueIndex+_length2);valueParts.push({part:_part2,beginIndex:valueIndex,endIndex:valueIndex+_length2-1});valueIndex+=_length2;maskIndex+=1;}}}return valueParts;};export default parseValue;","map":{"version":3,"sources":["C:/Users/Hovsep/Desktop/local/diflow_react/packages/app/src/pages/POA/MCHD_ROOT/common/Form/utils/parseValue.ts"],"names":["parseValue","mask","value","valueParts","valueIndex","maskIndex","undefined","length","item","found","fixed","push","part","beginIndex","endIndex","slice","regexp","minLength","Array","isArray","maxLength","test"],"mappings":"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","sourcesContent":["export interface IMask {\r\n  length?: number;\r\n  fixed?: string;\r\n  regexp?: RegExp;\r\n  placeholder?: string;\r\n}\r\n\r\n/**\r\n * Breaks the value up into mask parts\r\n * @param mask Mask\r\n * @param value Input value\r\n */\r\nconst parseValue = (mask: IMask[], value: string) => {\r\n  const valueParts: Array<{ part: string; beginIndex: number; endIndex: number }> = [];\r\n  let valueIndex: number = 0;\r\n  let maskIndex: number = 0;\r\n\r\n  while (value !== undefined && valueIndex < value.length && maskIndex < mask.length) {\r\n    const item = mask[maskIndex];\r\n    let found;\r\n\r\n    if (item.fixed) {\r\n      const { length } = item.fixed;\r\n\r\n      valueParts.push({\r\n        part: item.fixed,\r\n        beginIndex: valueIndex,\r\n        endIndex: valueIndex + length - 1\r\n      });\r\n\r\n      const part = value.slice(valueIndex, valueIndex + length);\r\n\r\n      if (part === item.fixed) {\r\n        valueIndex += length;\r\n      }\r\n\r\n      maskIndex += 1;\r\n      found = true;\r\n    }\r\n\r\n    if (!found) {\r\n      if (item.regexp) {\r\n        const minLength = (Array.isArray(item.length) && item.length[0]) || item.length || 1;\r\n        const maxLength =\r\n          (Array.isArray(item.length) && item.length[1]) ||\r\n          item.length ||\r\n          value.length - valueIndex;\r\n        let length = maxLength;\r\n\r\n        while (!found && length >= minLength) {\r\n          const part = value.slice(valueIndex, valueIndex + length);\r\n\r\n          if (item.regexp.test(part)) {\r\n            valueParts.push({\r\n              part,\r\n              beginIndex: valueIndex,\r\n              endIndex: valueIndex + length - 1\r\n            });\r\n\r\n            valueIndex += length;\r\n            maskIndex += 1;\r\n            found = true;\r\n          }\r\n\r\n          length -= 1;\r\n        }\r\n\r\n        if (!found) {\r\n          valueIndex = value.length;\r\n        }\r\n      } else {\r\n        const length = Array.isArray(item.length)\r\n          ? item.length[1]\r\n          : item.length || value.length - valueIndex;\r\n        const part = value.slice(valueIndex, valueIndex + length);\r\n\r\n        valueParts.push({\r\n          part,\r\n          beginIndex: valueIndex,\r\n          endIndex: valueIndex + length - 1\r\n        });\r\n\r\n        valueIndex += length;\r\n        maskIndex += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return valueParts;\r\n};\r\n\r\nexport default parseValue;\r\n"]},"metadata":{},"sourceType":"module"}