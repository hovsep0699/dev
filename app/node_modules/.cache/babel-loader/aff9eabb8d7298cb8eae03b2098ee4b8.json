{"ast":null,"code":"import deepmerge from'deepmerge';import rfdc from'rfdc';export var isObject=function isObject(value){return value!==null&&typeof value==='object'&&!Array.isArray(value);};export var removeEmpty=function removeEmpty(obj){var newObj={};Object.keys(obj).forEach(function(key){if(key.startsWith('__')){return;}else if(isObject(obj[key])){var cleanedObj=removeEmpty(obj[key]);if(Object.keys(cleanedObj).length){newObj[key]=cleanedObj;}}else if(Array.isArray(obj[key])){var arr=obj[key].map(function(item){if(isObject(item))return removeEmpty(item);return item;}).filter(function(item){if(isObject(item)&&Object.keys(item).length)return true;if(!isObject(item))return true;return false;});if(arr.length){newObj[key]=arr;}}else if(obj[key]!=null&&obj[key]!==''){newObj[key]=obj[key];// copy value\n}});return newObj;};export var combineMerge=function combineMerge(target,source,options){var destination=target.slice();source.forEach(function(item,index){if(typeof destination[index]==='undefined'){destination[index]=options.cloneUnlessOtherwiseSpecified(item,options);}else if(options.isMergeableObject(item)){destination[index]=deepmerge(target[index],item,options);}else if(target.indexOf(item)===-1){destination.push(item);}});return destination;};export var clone=rfdc();","map":{"version":3,"sources":["C:/Users/Hovsep/Desktop/local/diflow_react/packages/app/src/utils/ObjectUtil.js"],"names":["deepmerge","rfdc","isObject","value","Array","isArray","removeEmpty","obj","newObj","Object","keys","forEach","key","startsWith","cleanedObj","length","arr","map","item","filter","combineMerge","target","source","options","destination","slice","index","cloneUnlessOtherwiseSpecified","isMergeableObject","indexOf","push","clone"],"mappings":"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","sourcesContent":["import deepmerge from 'deepmerge';\r\nimport rfdc from 'rfdc';\r\n\r\nexport const isObject = (value) => {\r\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\r\n}\r\n\r\nexport const removeEmpty = obj => {\r\n  const newObj = {};\r\n\r\n  Object.keys(obj).forEach(key => {\r\n    if(key.startsWith('__')) {\r\n      return;\r\n    } else if (isObject(obj[key])) {\r\n      const cleanedObj = removeEmpty(obj[key]); \r\n\r\n      if (Object.keys(cleanedObj).length) {\r\n        newObj[key] = cleanedObj;\r\n      }\r\n    } else if(Array.isArray(obj[key])) {\r\n      const arr = obj[key].map(item => {\r\n        if(isObject(item)) return removeEmpty(item);\r\n        return item;\r\n      }).filter(item => {\r\n        if( isObject(item) && Object.keys(item).length) return true \r\n        if(!isObject(item)) return true;\r\n        return false ;\r\n      });\r\n\r\n      if(arr.length) {\r\n        newObj[key] = arr\r\n      }      \r\n    } else if (obj[key] != null && obj[key] !== '') {\r\n      newObj[key] = obj[key]; // copy value\r\n    }\r\n  });\r\n  \r\n  return newObj;\r\n};\r\n\r\nexport const combineMerge = (target, source, options) => {\r\n  const destination = target.slice();\r\n\r\n  source.forEach((item, index) => {\r\n    if (typeof destination[index] === 'undefined') {\r\n      destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);\r\n    } else if (options.isMergeableObject(item)) {\r\n      destination[index] = deepmerge(target[index], item, options);\r\n    } else if (target.indexOf(item) === -1) {\r\n      destination.push(item);\r\n    }\r\n  });\r\n  return destination;\r\n};\r\n\r\nexport const clone = rfdc();\r\n"]},"metadata":{},"sourceType":"module"}