{"ast":null,"code":"/**\r\n * Breaks the value up into mask parts\r\n * @param mask Mask\r\n * @param value Input value\r\n */\nvar parseValue = function parseValue(mask, value) {\n  var valueParts = [];\n  var valueIndex = 0;\n  var maskIndex = 0;\n\n  while (value !== undefined && valueIndex < value.length && maskIndex < mask.length) {\n    var item = mask[maskIndex];\n    var found = void 0;\n\n    if (item.fixed) {\n      var length = item.fixed.length;\n      valueParts.push({\n        part: item.fixed,\n        beginIndex: valueIndex,\n        endIndex: valueIndex + length - 1\n      });\n      var part = value.slice(valueIndex, valueIndex + length);\n\n      if (part === item.fixed) {\n        valueIndex += length;\n      }\n\n      maskIndex += 1;\n      found = true;\n    }\n\n    if (!found) {\n      if (item.regexp) {\n        var minLength = Array.isArray(item.length) && item.length[0] || item.length || 1;\n        var maxLength = Array.isArray(item.length) && item.length[1] || item.length || value.length - valueIndex;\n        var _length = maxLength;\n\n        while (!found && _length >= minLength) {\n          var _part = value.slice(valueIndex, valueIndex + _length);\n\n          if (item.regexp.test(_part)) {\n            valueParts.push({\n              part: _part,\n              beginIndex: valueIndex,\n              endIndex: valueIndex + _length - 1\n            });\n            valueIndex += _length;\n            maskIndex += 1;\n            found = true;\n          }\n\n          _length -= 1;\n        }\n\n        if (!found) {\n          valueIndex = value.length;\n        }\n      } else {\n        var _length2 = Array.isArray(item.length) ? item.length[1] : item.length || value.length - valueIndex;\n\n        var _part2 = value.slice(valueIndex, valueIndex + _length2);\n\n        valueParts.push({\n          part: _part2,\n          beginIndex: valueIndex,\n          endIndex: valueIndex + _length2 - 1\n        });\n        valueIndex += _length2;\n        maskIndex += 1;\n      }\n    }\n  }\n\n  return valueParts;\n};\n\nexport default parseValue;","map":{"version":3,"sources":["../../../src/Form/utils/parseValue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Breaks the value up into mask parts\r\n * @param mask Mask\r\n * @param value Input value\r\n */\r\nconst parseValue = (mask, value) => {\r\n    const valueParts = [];\r\n    let valueIndex = 0;\r\n    let maskIndex = 0;\r\n    while (value !== undefined && valueIndex < value.length && maskIndex < mask.length) {\r\n        const item = mask[maskIndex];\r\n        let found;\r\n        if (item.fixed) {\r\n            const { length } = item.fixed;\r\n            valueParts.push({\r\n                part: item.fixed,\r\n                beginIndex: valueIndex,\r\n                endIndex: valueIndex + length - 1\r\n            });\r\n            const part = value.slice(valueIndex, valueIndex + length);\r\n            if (part === item.fixed) {\r\n                valueIndex += length;\r\n            }\r\n            maskIndex += 1;\r\n            found = true;\r\n        }\r\n        if (!found) {\r\n            if (item.regexp) {\r\n                const minLength = (Array.isArray(item.length) && item.length[0]) || item.length || 1;\r\n                const maxLength = (Array.isArray(item.length) && item.length[1]) ||\r\n                    item.length ||\r\n                    value.length - valueIndex;\r\n                let length = maxLength;\r\n                while (!found && length >= minLength) {\r\n                    const part = value.slice(valueIndex, valueIndex + length);\r\n                    if (item.regexp.test(part)) {\r\n                        valueParts.push({\r\n                            part,\r\n                            beginIndex: valueIndex,\r\n                            endIndex: valueIndex + length - 1\r\n                        });\r\n                        valueIndex += length;\r\n                        maskIndex += 1;\r\n                        found = true;\r\n                    }\r\n                    length -= 1;\r\n                }\r\n                if (!found) {\r\n                    valueIndex = value.length;\r\n                }\r\n            }\r\n            else {\r\n                const length = Array.isArray(item.length)\r\n                    ? item.length[1]\r\n                    : item.length || value.length - valueIndex;\r\n                const part = value.slice(valueIndex, valueIndex + length);\r\n                valueParts.push({\r\n                    part,\r\n                    beginIndex: valueIndex,\r\n                    endIndex: valueIndex + length - 1\r\n                });\r\n                valueIndex += length;\r\n                maskIndex += 1;\r\n            }\r\n        }\r\n    }\r\n    return valueParts;\r\n};\r\nexport default parseValue;\r\n//# sourceMappingURL=parseValue.js.map"]},"metadata":{},"sourceType":"module"}